# src/core/app_controller.py
"""
Основной контроллер приложения Excel Micro DB.
Координирует работу всех компонентов системы.
"""
import sys
from pathlib import Path
from typing import Optional, Dict, Any

# Добавляем корень проекта в путь поиска модулей если нужно
project_root = Path(__file__).parent.parent.parent
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

from src.utils.logger import get_logger
from src.core.project_manager import ProjectManager
# --- ИНТЕГРАЦИЯ STORAGE: Импорт модуля хранения ---
from src.storage.database import ProjectDBStorage
# --- ИНТЕГРАЦИЯ ANALYZER: Импорт модуля анализа ---
from src.analyzer.logic_documentation import analyze_excel_file

# Получаем логгер для этого модуля
logger = get_logger(__name__)

class AppController:
    """
    Основной контроллер приложения Excel Micro DB.
    Отвечает за:
    - Инициализацию и управление компонентами приложения
    - Координацию между модулями (analyzer, processor, storage, exporter, constructor)
    - Управление состоянием приложения
    - Обработку ошибок на уровне приложения
    """
    def __init__(self, project_path: Optional[str] = None):
        """
        Инициализация контроллера приложения.
        Args:
            project_path (Optional[str]): Путь к директории проекта
        """
        logger.debug("Инициализация AppController")
        self.project_path = Path(project_path) if project_path else None
        self.project_manager: Optional[ProjectManager] = None
        self.is_initialized = False
        # Состояние приложения
        self.current_project: Optional[Dict[str, Any]] = None
        self.is_project_loaded = False
        logger.debug("AppController инициализирован")

    def initialize(self) -> bool:
        """
        Инициализация приложения и его компонентов.
        Returns:
            bool: True если инициализация успешна, False в противном случае
        """
        try:
            logger.info("Начало инициализации приложения")
            # Инициализация менеджера проектов
            self.project_manager = ProjectManager()
            # Если указан путь к проекту, загружаем его (без рекурсивного вызова initialize)
            if self.project_path and self.project_path.exists():
                # Прямая загрузка без проверки is_initialized
                logger.info(f"Загрузка проекта из: {self.project_path}")
                project_data = self.project_manager.load_project(str(self.project_path))
                if project_data:
                    self.current_project = project_data
                    self.is_project_loaded = True
                    logger.info("Проект загружен успешно")
                else:
                    logger.error("Не удалось загрузить проект")
            self.is_initialized = True
            logger.info("Инициализация приложения завершена успешно")
            return True
        except Exception as e:
            logger.error(f"Ошибка при инициализации приложения: {e}")
            self.is_initialized = False
            return False

    def create_project(self, project_path: str, project_name: Optional[str] = None) -> bool:
        """
        Создание нового проекта.
        Args:
            project_path (str): Путь к директории проекта
            project_name (Optional[str]): Название проекта (по умолчанию имя директории)
        Returns:
            bool: True если проект создан успешно, False в противном случае
        """
        if not self.is_initialized:
            logger.warning("Приложение не инициализировано. Выполняем инициализацию...")
            if not self.initialize():
                return False
        try:
            logger.info(f"Создание нового проекта в: {project_path}")
            if not self.project_manager:
                logger.error("Менеджер проектов не инициализирован")
                return False
            success = self.project_manager.create_project(project_path, project_name)
            if success:
                logger.info("Проект создан успешно")
                # Автоматически загружаем созданный проект
                self.load_project(project_path)
                return True
            else:
                logger.error("Не удалось создать проект")
                return False
        except Exception as e:
            logger.error(f"Ошибка при создании проекта: {e}")
            return False

    def load_project(self, project_path: str) -> bool:
        """
        Загрузка существующего проекта.
        Args:
            project_path (str): Путь к директории проекта
        Returns:
            bool: True если проект загружен успешно, False в противном случае
        """
        if not self.is_initialized:
            logger.warning("Приложение не инициализировано. Выполняем инициализацию...")
            if not self.initialize():
                return False
        try:
            logger.info(f"Загрузка проекта из: {project_path}")
            if not self.project_manager:
                logger.error("Менеджер проектов не инициализирован")
                return False
            project_data = self.project_manager.load_project(project_path)
            if project_data:
                self.current_project = project_data
                self.project_path = Path(project_path)
                self.is_project_loaded = True
                logger.info("Проект загружен успешно")
                return True
            else:
                logger.error("Не удалось загрузить проект")
                return False
        except Exception as e:
            logger.error(f"Ошибка при загрузке проекта: {e}")
            return False

    def analyze_excel_file(self, file_path: str, options: Optional[Dict[str, Any]] = None) -> bool:
        """
        Анализ Excel файла.
        Args:
            file_path (str): Путь к Excel файлу для анализа
            options (Optional[Dict[str, Any]]): Дополнительные опции анализа
        Returns:
            bool: True если анализ выполнен успешно, False в противном случае
        """
        if not self.is_project_loaded:
            logger.warning("Проект не загружен. Невозможно выполнить анализ")
            return False

        if not self.project_path:
            logger.error("Путь к проекту не установлен.")
            return False

        try:
            logger.info(f"Начало анализа файла: {file_path}")

            # Проверка существования файла
            if not Path(file_path).exists():
                logger.error(f"Файл не найден: {file_path}")
                return False

            # - ИНТЕГРАЦИЯ ANALYZER: Вызов анализатора -
            # Передаем опции анализа
            documentation_data = analyze_excel_file(file_path)
            if documentation_data is None:
                logger.error("Анализатор вернул None. Ошибка при анализе файла.")
                return False

            logger.info("Анализ файла завершен успешно")

            # --- НАЧАЛО ИЗМЕНЕНИЙ ---
            # Получаем имя проекта для сохранения результатов
            project_name = self.current_project.get("project_name", self.project_path.name)
            logger.info("Начало сохранения результатов анализа в хранилище")

            # Определяем путь к файлу БД
            db_path = self.project_path / "project_data.db"
            logger.debug(f"Путь к БД проекта: {db_path}")

            # Используем контекстный менеджер для автоматического управления соединением
            from src.storage.database import ProjectDBStorage
            try:
                with ProjectDBStorage(str(db_path)) as storage: # <-- connect() вызывается автоматически
                    logger.debug("Соединение с БД установлено (через контекстный менеджер)")
                    # Сохраняем результаты анализа
                    save_success = storage.save_analysis_results(project_name, documentation_data)

                # После выхода из блока 'with' соединение автоматически закрывается (disconnect())

                if save_success:
                    logger.info("Результаты анализа успешно сохранены в хранилище")
                    return True
                else:
                    logger.error("Ошибка при сохранении результатов анализа в хранилище")
                    return False

            except Exception as e:
                logger.error(f"Ошибка при работе с БД проекта: {e}", exc_info=True)
                return False

        except Exception as e:
                logger.error(f"Ошибка при анализе файла или сохранении в хранилище: {e}", exc_info=True)
                return False

    def process_data(self, config_path: str) -> bool:
        """
        Обработка данных по конфигурации.
        Args:
            config_path (str): Путь к конфигурационному файлу обработки
        Returns:
            bool: True если обработка выполнена успешно, False в противном случае
        """
        if not self.is_project_loaded:
            logger.warning("Проект не загружен. Невозможно выполнить обработку")
            return False
        try:
            logger.info(f"Начало обработки данных с конфигурацией: {config_path}")
            # TODO: Здесь будет интеграция с процессором
            # Пока только демонстрация логики
            if not Path(config_path).exists():
                logger.error(f"Конфигурационный файл не найден: {config_path}")
                return False
            # Здесь будет вызов модуля обработки
            # from src.processor.data_processor import process_data_with_config
            # result = process_data_with_config(config_path)
            logger.info("Обработка данных завершена успешно")
            return True
        except Exception as e:
            logger.error(f"Ошибка при обработке данных: {e}")
            return False

    def export_results(self, export_type: str, output_path: str) -> bool:
        """
        Экспорт результатов.
        Args:
            export_type (str): Тип экспорта (например, 'documentation', 'report', 'data', 'excel').
                               Пока поддерживается только 'excel'.
            output_path (str): Путь для сохранения результата.
        Returns:
            bool: True если экспорт выполнен успешно, False в противном случае.
        """
        if not self.is_project_loaded:
            logger.warning("Проект не загружен. Невозможно выполнить экспорт.")
            return False

        if not self.project_path:
            logger.error("Путь к проекту не установлен.")
            return False

        # Пока поддерживаем только экспорт в Excel
        if export_type.lower() != 'excel':
            logger.warning(f"Тип экспорта '{export_type}' пока не поддерживается. Поддерживается только 'excel'.")
            # TODO: Здесь можно добавить поддержку других типов экспорта позже
            return False

        try:
            logger.info(f"Начало экспорта проекта в Excel: {output_path}")
            
            # --- ИНТЕГРАЦИЯ EXPORTER ---
            # Импортируем функцию экспорта прямо здесь, чтобы избежать циклических импортов
            # на уровне модуля, если exporter когда-нибудь будет импортировать AppController.
            from src.exporter.excel_exporter import export_project_to_excel
            
            # Вызываем функцию экспорта, передавая путь к проекту и путь к выходному файлу
            # Определяем путь к БД проекта
            db_path = self.project_path / "project_data.db"

            success = export_project_to_excel(
                db_path=str(db_path),
                project_path=str(self.project_path),
                output_path=output_path
            )

            if success:
                logger.info("Экспорт в Excel завершен успешно.")
                return True
            else:
                logger.error("Ошибка при экспорте в Excel.")
                return False

        except Exception as e:
            logger.error(f"Ошибка при экспорте результатов: {e}", exc_info=True)
            return False



    def get_project_info(self) -> Optional[Dict[str, Any]]:
        """
        Получение информации о текущем проекте.
        Returns:
            Optional[Dict[str, Any]]: Информация о проекте или None если проект не загружен
        """
        if not self.is_project_loaded or not self.current_project:
            logger.warning("Проект не загружен")
            return None
        return self.current_project

    def shutdown(self) -> None:
        """
        Корректное завершение работы приложения.
        """
        logger.info("Завершение работы приложения")
        # Здесь можно добавить сохранение состояния, закрытие соединений и т.д.
        if self.project_manager:
            self.project_manager.cleanup()
        logger.info("Приложение завершено")

# Функции для удобного использования контроллера
def create_app_controller(project_path: Optional[str] = None) -> AppController:
    """
    Фабричная функция для создания экземпляра AppController.
    Args:
        project_path (Optional[str]): Путь к директории проекта
    Returns:
        AppController: Экземпляр контроллера приложения
    """
    controller = AppController(project_path)
    return controller

# Пример использования
if __name__ == "__main__":
    # Это просто для демонстрации, не будет выполняться при импорте
    logger.info("Демонстрация работы AppController")
    # Создание контроллера
    app = create_app_controller()
    # Инициализация
    if app.initialize():
        logger.info("Контроллер приложения инициализирован успешно")
    else:
        logger.error("Ошибка инициализации контроллера приложения")
