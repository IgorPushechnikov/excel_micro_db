# src/constructor/widgets/sheet_editor.py
"""
Виджет-редактор для отображения содержимого листа Excel.
"""
import sys
from typing import Optional, Dict, Any, List
from pathlib import Path

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QTableView, QLabel, QMessageBox,
    QAbstractItemView, QHeaderView
)
from PySide6.QtCore import Qt, QAbstractTableModel, QModelIndex, Slot, Signal
from PySide6.QtGui import QBrush, QColor
import sqlite3
import logging

from src.utils.logger import get_logger

logger = get_logger(__name__)


class SheetDataModel(QAbstractTableModel):
    """
    Модель данных для отображения содержимого листа в QTableView.
    """
    def __init__(self, raw_data: Dict[str, Any], parent=None):
        super().__init__(parent)
        self._raw_data = raw_data
        self._column_names = self._raw_data.get("column_names", [])
        self._rows = self._raw_data.get("rows", [])

    def rowCount(self, parent=QModelIndex()):
        """Возвращает количество строк."""
        # logger.debug(f"SheetDataModel.rowCount: {len(self._rows)}")
        return len(self._rows)

    def columnCount(self, parent=QModelIndex()):
        """Возвращает количество столбцов."""
        # logger.debug(f"SheetDataModel.columnCount: {len(self._column_names)}")
        return len(self._column_names)

    def data(self, index: QModelIndex, role=Qt.ItemDataRole.DisplayRole):
        """Возвращает данные для отображения в ячейке."""
        if not index.isValid():
            return None

        row = index.row()
        col = index.column()

        if role == Qt.ItemDataRole.DisplayRole:
            # Отображаемое значение
            if row < len(self._rows) and col < len(self._rows[row]):
                value = self._rows[row][col]
                # Преобразуем None в пустую строку для отображения
                return str(value) if value is not None else ""
                
        elif role == Qt.ItemDataRole.ToolTipRole:
             # Подсказка с "сырым" значением
            if row < len(self._rows) and col < len(self._rows[row]):
                value = self._rows[row][col]
                return f"Значение: {repr(value)}" # repr показывает None, '' и т.д. явно

        # TODO: Здесь можно добавить оформление (цвет фона, шрифт) на основе стилей из БД
        # elif role == Qt.ItemDataRole.BackgroundRole:
        #     # Например, установить светло-серый фон для пустых ячеек
        #     if row < len(self._rows) and col < len(self._rows[row]):
        #         value = self._rows[row][col]
        #         if value is None or str(value).strip() == "":
        #             return QBrush(QColor(240, 240, 240)) # Светло-серый

        return None

    def headerData(self, section, orientation, role=Qt.ItemDataRole.DisplayRole):
        """Возвращает данные для заголовков."""
        if role == Qt.ItemDataRole.DisplayRole:
            if orientation == Qt.Orientation.Horizontal and section < len(self._column_names):
                return self._column_names[section]
            elif orientation == Qt.Orientation.Vertical:
                return str(section + 1) # Нумерация строк с 1
        return None


class SheetEditor(QWidget):
    """
    Виджет для редактирования/просмотра содержимого одного листа.
    """
    # Сигнал, испускаемый при запросе открытия другого листа (пока не используется)
    # sheet_open_requested = Signal(str)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.project_db_path: Optional[str] = None
        self.sheet_name: Optional[str] = None
        self._model: Optional[SheetDataModel] = None
        self._setup_ui()

    def _setup_ui(self):
        """Настройка пользовательского интерфейса."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        # Заголовок с именем листа
        self.label_sheet_name = QLabel("Лист: <Не выбран>")
        self.label_sheet_name.setStyleSheet("font-weight: bold; padding: 5px;")
        layout.addWidget(self.label_sheet_name)

        # Таблица для отображения данных
        self.table_view = QTableView()
        self.table_view.setAlternatingRowColors(True)
        self.table_view.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectItems)
        self.table_view.setSelectionMode(QAbstractItemView.SelectionMode.ContiguousSelection)
        
        # Настройка заголовков
        horizontal_header = self.table_view.horizontalHeader()
        horizontal_header.setSectionResizeMode(QHeaderView.ResizeMode.Interactive)
        # horizontal_header.setStretchLastSection(True) # Растягивать последний столбец
        
        vertical_header = self.table_view.verticalHeader()
        vertical_header.setSectionResizeMode(QHeaderView.ResizeMode.Fixed)
        vertical_header.setDefaultSectionSize(20) # Высота строк

        layout.addWidget(self.table_view)

    def load_sheet(self, project_db_path: str, sheet_name: str):
        """
        Загружает и отображает содержимое листа.

        Args:
            project_db_path (str): Путь к файлу БД проекта.
            sheet_name (str): Имя листа для загрузки.
        """
        logger.info(f"Загрузка листа '{sheet_name}' из БД: {project_db_path}")
        self.project_db_path = project_db_path
        self.sheet_name = sheet_name
        self.label_sheet_name.setText(f"Лист: {sheet_name}")

        try:
            raw_data = self._load_raw_data_from_db(project_db_path, sheet_name)
            if raw_data is not None:
                self._model = SheetDataModel(raw_data)
                self.table_view.setModel(self._model)
                logger.info(f"Лист '{sheet_name}' успешно загружен в редактор. "
                            f"Строк: {len(raw_data.get('rows', []))}, "
                            f"Столбцов: {len(raw_data.get('column_names', []))}")
                
                # Автоматически подгоняем размер первой колонки под содержимое
                # self.table_view.resizeColumnToContents(0)
            else:
                # Очищаем модель, если данные не получены
                self.table_view.setModel(None)
                self._model = None
                logger.warning(f"Данные для листа '{sheet_name}' не найдены или ошибка загрузки.")
                # Можно показать сообщение в таблице или статус баре
                
        except Exception as e:
            logger.error(f"Ошибка при загрузке листа '{sheet_name}': {e}", exc_info=True)
            QMessageBox.critical(
                self, 
                "Ошибка загрузки", 
                f"Не удалось загрузить содержимое листа '{sheet_name}':\n{e}"
            )
            # Очищаем модель в случае ошибки
            self.table_view.setModel(None)
            self._model = None

    def _load_raw_data_from_db(self, db_path: str, sheet_name: str) -> Optional[Dict[str, Any]]:
        """
        Загружает "сырые" данные листа из БД проекта.

        Args:
            db_path (str): Путь к файлу БД.
            sheet_name (str): Имя листа.

        Returns:
            Optional[Dict[str, Any]]: Словарь с ключами 'column_names' и 'rows',
                                      или None в случае ошибки.
        """
        try:
            logger.debug(f"Подключение к БД для загрузки данных листа '{sheet_name}': {db_path}")
            with sqlite3.connect(db_path) as conn:
                conn.row_factory = sqlite3.Row
                cursor = conn.cursor()

                # 1. Находим ID листа
                cursor.execute("SELECT id FROM sheets WHERE name = ?", (sheet_name,))
                sheet_row = cursor.fetchone()
                if not sheet_row:
                    logger.error(f"Лист '{sheet_name}' не найден в БД.")
                    return None

                sheet_id = sheet_row['id']
                logger.debug(f"ID листа '{sheet_name}': {sheet_id}")

                # 2. Находим имя таблицы с сырыми данными
                cursor.execute(
                    "SELECT table_name FROM raw_data_tables_registry WHERE sheet_id = ?", 
                    (sheet_id,)
                )
                registry_row = cursor.fetchone()
                if not registry_row:
                    logger.warning(f"Таблица сырых данных для листа '{sheet_name}' (ID: {sheet_id}) не найдена в реестре.")
                    # Возвращаем пустую структуру
                    return {"column_names": [], "rows": []}

                raw_table_name = registry_row['table_name']
                logger.debug(f"Имя таблицы сырых данных: {raw_table_name}")

                # 3. Получаем имена столбцов
                # Пробуем получить их из таблицы sheets.raw_data_info (JSON)
                # Если не удается, получаем из самой таблицы сырых данных
                column_names = []
                cursor.execute("SELECT raw_data_info FROM sheets WHERE id = ?", (sheet_id,))
                raw_data_info_row = cursor.fetchone()
                if raw_data_info_row and raw_data_info_row['raw_data_info']:
                    import json
                    try:
                        raw_data_info = json.loads(raw_data_info_row['raw_data_info'])
                        column_names = raw_data_info.get('column_names', [])
                        logger.debug(f"Имена столбцов из raw_data_info: {column_names}")
                    except json.JSONDecodeError:
                        logger.warning("Не удалось распарсить raw_data_info JSON.")
                
                if not column_names:
                     # Получаем имена столбцов напрямую из таблицы
                     # Этот запрос может быть медленным для больших таблиц
                    query_columns = f"PRAGMA table_info('{raw_table_name}')"
                    cursor.execute(query_columns)
                    columns_info = cursor.fetchall()
                    # Пропускаем служебный столбец 'id'
                    column_names = [col['name'] for col in columns_info if col['name'] != 'id']
                    logger.debug(f"Имена столбцов из PRAGMA table_info: {column_names}")


                if not column_names:
                    logger.warning(f"Не удалось определить имена столбцов для листа '{sheet_name}'.")
                    return {"column_names": [], "rows": []}

                # 4. Получаем сами данные
                # Экранируем имя таблицы на случай специальных символов
                query_data = f"SELECT * FROM \"{raw_table_name}\""
                cursor.execute(query_data)
                data_rows = cursor.fetchall()

                # Преобразуем sqlite3.Row в список списков, исключая столбец 'id'
                processed_rows = []
                for row in data_rows:
                    # Создаем список значений для строки, исключая 'id'
                    row_values = [row[col_name] for col_name in column_names]
                    processed_rows.append(row_values)
                
                logger.debug(f"Загружено {len(processed_rows)} строк данных для листа '{sheet_name}'.")

                return {
                    "column_names": column_names,
                    "rows": processed_rows
                }

        except sqlite3.Error as e:
            logger.error(f"Ошибка SQLite при загрузке данных листа '{sheet_name}': {e}")
            return None
        except Exception as e:
            logger.error(f"Неожиданная ошибка при загрузке данных листа '{sheet_name}': {e}", exc_info=True)
            return None

    def clear_sheet(self):
        """Очищает отображение листа."""
        logger.debug("Очистка редактора листа")
        self.project_db_path = None
        self.sheet_name = None
        self.label_sheet_name.setText("Лист: <Не выбран>")
        self.table_view.setModel(None)
        self._model = None
